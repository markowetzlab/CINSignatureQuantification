#' fitMixturePois
#'
#' Fit mixture model using flexmix to set of components with Poisson
#' distributions
#'
#' @param component two-dimensional data.frame containing sample names and
#'   values of computed copy number features generated by calculateFeatures()
#' @param seed Numeric or string as a input value for set.seed() function -
#'   Currently disabled (Default: NULL)
#' @param model_selection String to specify model selection method of available
#'   "AIC", "BIC", or "ICL" (default: "BIC")
#' @param min_prior FLXcontrol value - Minimum prior probability of clusters,
#'   components falling below this threshold are removed during the iteration
#'   (default: 0.001)
#' @param niter FLXcontrol value - Maximum number of iterations per component k
#'   (default: 1000)
#' @param nrep Number of random initialisations to run per mixture component
#'   step (default: 1)
#' @param min_comp Minimum of mixture components k to compute (default: 2)
#' @param max_comp Minimum of mixture components k to compute (default: 10)
#' @param iters Number of repeated runs to perform of Poisson mixture model
#'   fitting. The modal value for number of components is selected from the
#'   total number of iterations and the model with the best model selection
#'   value returned (Default: 1)
#' @param parallel Use doFuture parallelism (default: FALSE)
#' @returns data.table containing the mean and weights of fitted poisson mixture
#'   models
#' @export fitMixturePois
#'
fitMixturePois <- function(component=NULL,seed=NULL,model_selection="BIC",
                           min_prior=0.001,niter=1000,nrep=1,min_comp=2,
                           max_comp=10,iters=1,parallel=FALSE){
    if(!requireNamespace("flexmix", quietly = TRUE)){
        stop("package 'flexmix' is not installed and is required to fit mixture models")
    }
    if(is.null(component)){
        stop("component is null")
    }
    if(!is.null(seed)){
        set.seed(seed)
    }
    if(min_comp >= max_comp){
        stop("minimum number of components should be less than maximum")
    }
    # capture args
    argg <- unlist(c(as.list(environment()))[-1])
    # set the column names to fix bpchrarm naming
    colnames(component) <- c("ID","value")

    control <- generateControl(min_prior = min_prior, niter = niter)

    model <- fitPoisModel(component = component$value,min_comp = min_comp,
                          max_comp = max_comp,nrep = nrep, control = control,
                          model_selection = model_selection,iters=iters,parallel=parallel)
    modelArg <- append(model,argg)
    return(modelArg)
}

generateControl <- function(min_prior,niter){
    control <- methods::new("FLXcontrol")
    control@minprior <- min_prior
    control@iter.max <- niter
    return(control)
}

fitPoisModel <- function(component,min_comp,max_comp,nrep,control,model_selection,iters,parallel){
    fitPoismessage <- paste0("fitting poisson mixture models")
    message(fitPoismessage)
    if(iters == 1){
        fit <- flexmix::stepFlexmix(component ~ 1,verbose = F,
                                model = flexmix::FLXMCmvpois(),
                                k=min_comp:max_comp,nrep=nrep,control=control)
        fit <- flexmix::getModel(fit,which=model_selection)
        fit <- list(model=fit,iterk=fit@k,k=fit@k)
    } else {
        if(!parallel){
            iterlist <- list()
            for(i in 1:iters){
                message(paste0("Iteration ",i," of ",iters))
                ifit <- flexmix::stepFlexmix(component ~ 1,verbose = T,
                                        model = flexmix::FLXMCmvpois(),
                                        k=min_comp:max_comp,nrep=nrep,control=control)

                ifit <- flexmix::getModel(ifit,which=model_selection)
                iterlist <- append(iterlist,list(ifit))
            }
        } else {
            message(paste0("Running iterations across ",future::nbrOfWorkers()," threads"))
            `%dofuture%` <- doFuture::`%dofuture%`
            p <- progressr::progressor(steps = iters)
            i <- NULL
            iterlist = foreach::foreach(i=1:iters,.options.future = list(seed = TRUE,packages = c("CINSignatureQuantification"))) %dofuture% {
                ifit <- flexmix::stepFlexmix(component ~ 1,verbose = T,
                                             model = flexmix::FLXMCmvpois(),
                                             k=min_comp:max_comp,nrep=nrep,control=control)

                ifit <- flexmix::getModel(ifit,which=model_selection)
                p(sprintf("i=%g", i))
            }
        }
        fit <- getBestModel(iterlist,model_selection=model_selection)
    }
    return(fit)
}

formatPoisModel <- function(model){
    componentMeans <- modeltools::parameters(model)
    ## get prior probability for component assignment
    ## equivalent to colSums(fitted@posterior$scaled) / sum(fitted@posterior$scaled)
    componentPriors <- modeltools::prior(model)
    CompTab <- data.table::data.table(Mean = componentMeans,Weight = componentPriors)
    CompTab <- CompTab[order(CompTab$Mean)]
    return(CompTab)
}

getBestModel <- function(models,model_selection){
    modeV <- unlist(lapply(models,FUN = function(y) y@k))
    print(table(modeV))
    mixtureMode <- collapse::fmode(modeV,ties="min")
    message(paste0("Selecting modal k = ",mixtureMode))
    models <- models[which(modeV == mixtureMode)]
    bestSolutionMAX <- Inf
    bestmodel <- NA
    message(paste0("Picking best model based on ",model_selection,"..."))
    for(model in models) {
        switch(model_selection,
               BIC={
                   IC = abs(BIC(model))
               },
               AIC={
                   IC = abs(AIC(model))
               },
               ICL={
                   IC = abs(ICL(model))
               })
        if(IC < bestSolutionMAX) {
            message(paste0("...Current best IC: ",bestSolutionMAX))
            bestSolutionMAX = IC
            bestmodel = model
        }
    }
    #message(paste0("best model based on ",model_selection," - ",bestSolutionMAX))
    return(list(model=bestmodel,iterk=modeV,k=mixtureMode))
}

