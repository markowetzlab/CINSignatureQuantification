#' fitMixturePois
#'
#' Fit mixture model using flexmix to set of components with Poisson
#' distributions
#'
#' @param component two-dimensional data.frame containing sample names and
#'   values of computed copy number features generated by calculateFeatures()
#' @param seed Numeric or string as a input value for set.seed() function -
#'   Currently disabled (Default: NULL)
#' @param model_selection String to specify model selection method of available
#'   "AIC", "BIC", or "ICL" (default: "BIC")
#' @param min_prior FLXcontrol value - Minimum prior probability of clusters,
#'   components falling below this threshold are removed during the iteration
#'   (default: 0.001)
#' @param niter FLXcontrol value - Maximum number of iterations per component k
#'   (default: 1000)
#' @param nrep Number of random initialisations to run per mixture component
#'   step (default: 1)
#' @param min_comp Minimum of mixture components k to compute (default: 2)
#' @param max_comp Minimum of mixture components k to compute (default: 10)
#' @param iters Number of repeated runs to perform of Poisson mixture model
#'   fitting. The modal value for number of components is selected from the
#'   total number of iterations and the model with the best model selection
#'   value returned (Default: 1)
#' @returns data.table containing the mean and weights of fitted poisson mixture
#'   models
fitMixturePois <- function(component=NULL,seed=NULL,model_selection="BIC",min_prior=0.001,niter=1000,nrep=1,min_comp=2,max_comp=10,iters=1){
    if(!requireNamespace("flexmix", quietly = TRUE)){
        stop("package 'flexmix' is not installed and is required to fit mixture models")
    }
    if(is.null(component)){
        stop("component is null")
    }
    if(!is.null(seed)){
        set.seed(seed)
    }

    # set the column names to fix bpchrarm naming
    colnames(component) <- c("ID","value")

    control <- generateControl(min_prior = min_prior, niter = niter)

    model <- fitPoisModel(component = component$value,min_comp = min_comp,
                          max_comp = max_comp,nrep = nrep, control = control,
                          model_selection = model_selection,iters=iters)
    return(model)
}

generateControl <- function(min_prior,niter){
    control <- methods::new("FLXcontrol")
    control@minprior <- min_prior
    control@iter.max <- niter
    return(control)
}

fitPoisModel <- function(component,min_comp,max_comp,nrep,control,model_selection,iters){
    fitPoismessage <- paste0("fitting poisson mixture models")
    message(fitPoismessage)
    if(iters == 1){
        fit <- flexmix::stepFlexmix(component ~ 1,verbose = T,
                                model = flexmix::FLXMCmvpois(),
                                k=min_comp:max_comp,nrep=nrep,control=control)
        fit <- flexmix::getModel(fit,which=model_selection)
    } else {
        iterlist <- list()
        for(i in 1:iters){
            message(paste0("Iteration ",i," of ",iters))
            ifit <- flexmix::stepFlexmix(component ~ 1,verbose = T,
                                    model = flexmix::FLXMCmvpois(),
                                    k=min_comp:max_comp,nrep=nrep,control=control)

            ifit <- flexmix::getModel(ifit,which=model_selection)
            iterlist <- append(iterlist,list(ifit))
        }
        fit <- getBestModel(iterlist,model_selection=model_selection)
    }
    return(fit)
}

formatPoisModel <- function(model){
    componentMeans <- modeltools::parameters(model)
    ## get prior probability for component assignment
    ## equivalent to colSums(fitted@posterior$scaled) / sum(fitted@posterior$scaled)
    componentPriors <- modeltools::prior(model)
    CompTab <- data.table::data.table(Mean = componentMeans,Weight = componentPriors)
    CompTab <- CompTab[order(CompTab$Mean)]
    return(CompTab)
}

getBestModel <- function(models,model_selection){
    modeV <- unlist(lapply(models,FUN = function(y) y@k))
    mixtureMode <- getModalValue(modeV)
    message(paste0("Modal k: ",mixtureMode))
    models <- models[which(modeV == mixtureMode)]
    bestSolutionMAX <- Inf
    bestmodel <- NA
    for(model in models) {
        switch(model_selection,
               BIC={
                   IC = abs(BIC(model))
               },
               AIC={
                   IC = abs(AIC(model))
               },
               ICL={
                   IC = abs(ICL(model))
               })
        if(IC < bestSolutionMAX) {
            message(paste0("Current best IC: ",bestSolutionMAX))
            bestSolutionMAX = IC
            bestmodel = model
        }
    }
    return(bestmodel)
}

getModalValue <- function(x){
    m <- as.numeric(names(sort(table(x))[1]))
    return(m)
}
