---
title: "osCN-chain-count"
author: "Philip Smith"
date: "`r Sys.Date()`"
output: html_document
---
# os chain count
- https://github.com/markowetzlab/CINSignatureQuantification/issues/22

Issue opened on `CINSignatureQuantification` package identified a potential issue with the `osCN` chain length feature function in which chains where the last "link" of a chain coincided with the terminus of a chromosome were not included in the final feature count vector.

## set up

```{r libs,message=F}
library(ggplot2)
library(dplyr)
library(tidyr)
library(tibble)
library(data.table)
library(ComplexHeatmap)
library(ggplot2)
library(igraph)
library(qgraph)
library(lsa)
library(mclust)
library(ggthemes)
library(ggalluvial)
library(CINSignatureQuantification) # install getOS-count branch of package
```

```{r funcs}
source("osCN_source_funcs.R")
```

## Preliminary count check

Generate some basic "genomes" with differing segment positions and oscillating chains

```{r generate_test_segs}
segTab_internal_chains <- data.frame(chromosome=c(rep("chr1",times=7),rep("chr2",times=7)),
                 start=rep(c(1,100,200,300,400,500,600),times=2),
                 end=rep(c(99,199,299,399,499,599,699),times=2),
                 segVal=c(c(2,2,4,3,4,2,2),c(2,2,4,3,4,2,2)),
                 sample=c(rep("sample1",times=14)))

segTab_chr2_end_chains <- data.frame(chromosome=c(rep("chr1",times=7),rep("chr2",times=7)),
                                     start=rep(c(1,100,200,300,400,500,600),times=2),
                                     end=rep(c(99,199,299,399,499,599,699),times=2),
                                     segVal=c(c(2,2,4,3,4,2,2),c(2,2,4,3,4,3,4)),
                                     sample=c(rep("sample1",times=14)))

segTab_twochains_chains <- data.frame(chromosome=c(rep("chr1",times=7),rep("chr2",times=7)),
                                     start=rep(c(1,100,200,300,400,500,600),times=2),
                                     end=rep(c(99,199,299,399,499,599,699),times=2),
                                     segVal=c(c(4,3,4,2,3,4,3),c(4,3,4,3,4,3,4)),
                                     sample=c(rep("sample1",times=14)))
```

Generated test cases were check using both the original and "fixed" implementation and demonstrate that the existing function fails to capture any chain in which the terminating segment is the same as the last segment in a given chromosome.

```{r test_int_chains,warning=FALSE,message=FALSE}
int_chain_nofix <- testOC(segTab = segTab_internal_chains)
int_chains_fix <- testOC(segTab = segTab_internal_chains,usefix = T)

reportChain(int_chain_nofix,int_chains_fix)
plotSegments(createCNQuant(segTab_internal_chains),sample = 1)
```

```{r test_end_chain,warning=FALSE,message=FALSE}
chr2_end_chain_nofix <- testOC(segTab = segTab_chr2_end_chains)
chr2_end_chains_fix <- testOC(segTab = segTab_chr2_end_chains,usefix = T)

reportChain(chr2_end_chain_nofix,chr2_end_chains_fix)
plotSegments(createCNQuant(segTab_chr2_end_chains),sample = 1)
```

```{r test_two_chains,warning=FALSE}
twochains_chain_nofix <- testOC(segTab = segTab_twochains_chains)
twochains_chains_fix <- testOC(segTab = segTab_twochains_chains,usefix = T)

reportChain(twochains_chain_nofix,twochains_chains_fix)
plotSegments(createCNQuant(segTab_twochains_chains),sample = 1)
```

## Check features - TCGA gold set

To assess the extent of difference in the existing and fixed implementation of osCN feature the two versions were computed across the TCGA 478 sample gold standard set provided with the CINSignatureQuantification package

```{r generate_signatures_tcga_gold}
# Generate full set of data for gold standard set using existing code as reference
qSigs <- quantifyCNSignatures(TCGA_478_Samples_SNP6_GOLD,method = "drews",build = "hg19",experimentName = "osCNtest")

# Split segment table into list for direct feature extraction using newly adapted getOscillationDrewsV2 function
TCGA_478_Samples_SNP6_GOLD_list <- split(TCGA_478_Samples_SNP6_GOLD,f = TCGA_478_Samples_SNP6_GOLD$sample)
q_noFix <- getOscillationDrews(TCGA_478_Samples_SNP6_GOLD_list)
q_Fix <- getOscillationDrewsV2(TCGA_478_Samples_SNP6_GOLD_list)

# adjustment to output type
q_noFix$value <- as.numeric(q_noFix$value)
q_Fix$value <- as.numeric(q_Fix$value)
```

```{r add_fixed_osCN_feat_to_sigquant_tcga_gold}
# Create a new CNQuant object from CINSignatureQuantification package and overwrite the existing osCN with the computed "fixed" osCN
qSigsFix <- createCNQuant(TCGA_478_Samples_SNP6_GOLD,build = "hg19",experimentName = "osCNtest")
qSigsFix <- calculateFeatures(qSigsFix,method = "drews")
qSigsFix@featData$osCN <- q_Fix

# Check that the data is matching and in the correct slot
all(qSigsFix@featData$osCN == q_Fix)

# Calculate the SxC and activities using the old weights and signature definitions
qSigsFix <- calculateSampleByComponentMatrix(qSigsFix)
qSigsFix <- calculateActivity(qSigsFix)
```

Implementation of the osCN feature fix results in an increase in both number of chains, total length of chains, and shifted distribution of chain lengths.

```{r test_chain_counts_tcga_gold}
qFeatsNofix <- q_noFix
qFeatsfix <- q_Fix

sum(qFeatsNofix$value > 0)
sum(qFeatsfix$value > 0)

chain_counts <- data.frame(getOS_method=factor(c("original","fixed"),levels = c("original","fixed")),
                           chains=c(sum(qFeatsNofix$value > 0),sum(qFeatsfix$value > 0)))

ggplot(chain_counts) +
    geom_col(aes(getOS_method,chains,fill=getOS_method)) +
    geom_text(aes(getOS_method,chains-400,
                  label=paste0(chains," (",(round(chains / sum(qFeatsNofix$value > 0),digits = 3))*100,"%)"))) +
    labs(title = "Chain counts (TCGA 478 gold standard)") +
    theme_bw() +
    theme(legend.position = "bottom",axis.title.x = element_blank())
```

```{r test_chain_lengths_tcga_gold}
chain_lengths <- data.frame(getOS_method=factor(c("original","fixed"),levels = c("original","fixed")),
                           chain_lengths=c(sum(qFeatsNofix$value),sum(qFeatsfix$value)))

ggplot(chain_lengths) +
    geom_col(aes(getOS_method,chain_lengths,fill=getOS_method)) +
    geom_text(aes(getOS_method,chain_lengths-400,
                  label=paste0(chain_lengths," (",(round(chain_lengths / sum(qFeatsNofix$value),digits = 3))*100,"%)"))) +
    labs(title = "Chain lengths (TCGA 478 gold standard)") +
    theme_bw() +
    theme(legend.position = "bottom",axis.title.x = element_blank())
```

```{r test_chain_density_tcga_gold}
chain_density <- data.frame(getOS_method=factor(c(rep("original",times=length(qFeatsNofix$value)),
                                                 rep("fixed",times=length(qFeatsfix$value))),c("original","fixed")),
                                               value=c(qFeatsNofix$value,qFeatsfix$value))

#chain_density <- chain_density[chain_density$value != 0,]

summary(chain_density$value[chain_density$getOS_method == "original"])
summary(chain_density$value[chain_density$getOS_method == "fixed"])

ggplot(chain_density[chain_density$value < 10,]) +
    geom_density(aes(value,fill=getOS_method),alpha=0.4) +
    labs(title = "Chain length distribution (TCGA 478 gold standard)") +
    theme_bw() +
    theme(legend.position = "bottom",axis.title.x = element_blank())

ggplot(chain_density[chain_density$value < 10,]) +
    geom_density(aes(value,fill=getOS_method),alpha=0.4) +
    labs(title = "Chain length distribution (TCGA 478 gold standard)") +
    theme_bw() +
    theme(legend.position = "bottom",axis.title.x = element_blank()) +
    facet_wrap(.~getOS_method)
```

Recomputing signature activities with fixed osCN feature, without reimplementation of mixture modelling or signature derivation results in a shift of various signatures

```{r sig_act_diffs_tcga_gold}
qDiff <- getActivities(qSigsFix) - getActivities(qSigs)
barplot(colMeans(qDiff),main = "Mean activity change")
barplot(colMeans(qDiff) / colMeans(getActivities(qSigs)),main = "normalised mean activity change")
```
```{r sig_act_corr_tcga_gold}
cancorr <- cor(getActivities(qSigs),getActivities(qSigsFix))
corrplot::corrplot(cancorr)
```

## Refitting mixtures on pan-cancer
### OLD vs NEW PAN CANCER osCN mixture modelling

```{r read_processed_segment_data_tcga_6335}
# Read CN segment data after filtering, smoothing etc.
# Do a load_all(CINSignatureQuantification) if needed
segs_table <- readRDS("data/0_TCGA_Segments_dCIN.rds")
segs <- split(segs_table,f = segs_table$sample)
length(segs)
```

```{r load_features_existing_tcga_6335}
# Load existing feats computed for publication
existingFeats <- readRDS("data/1_tcga_filtered_ecnf.rds")
dim(existingFeats$osCN)
```

```{r recalc_osCN_original_func_tcga_6335}
## Original drews function to compute osCN using package functions
osCN_nofix <- getOscillationDrews(segs)
dim(osCN_nofix)
```

```{r compare_old_v_recalculated_tcga_6335}
# New versions of old osCN match publication version of features using 6335 curated samples
all(existingFeats$osCN == osCN_nofix)
```

```{r calc_newfixed_osCN_tcga_6335}
## fixed osCN drews function with fix to compute osCN using package functions
osCN_fix <- getOscillationDrewsV2(segs)
dim(osCN_fix)
```

```{r mixtureModellingPoisson_tcga_6335}
## Implementation of 23_Fit_MixtureModels.R condensed functions to run as single line

# Original osCN from paper
osCN_original_pub_mixtureModel <- Drews2022_TCGA_Mixture_Models$osCN

# Run Poisson mixture using same publication parameters 100 times and use modal k and BIC
## Rerun or load original re-implemented osCN feat mixture model
if(!file.exists("data/osCN_noFix_mixtureModel_refitted.rds")){
    osCN_noFix_mixtureModel <- fitMixturePois(osCN_nofix,seed = NULL,iters = 100,
                                                                           max_comp = 5,cores = 11)
    saveRDS(osCN_noFix_mixtureModel,file = "data/osCN_noFix_mixtureModel_refitted.rds")
} else {
    osCN_noFix_mixtureModel <- readRDS("data/osCN_noFix_mixtureModel_refitted.rds")
}

# Rerun or load new fixed osCN feat mixture model
if(!file.exists("data/osCN_Fix_mixtureModel_newlyfitted.rds")){
    osCN_Fix_mixtureModel <- fitMixturePois(osCN_fix,seed = NULL,iters = 100,
                                                                            max_comp = 5,cores = 11)
    saveRDS(osCN_Fix_mixtureModel,file = "data/osCN_Fix_mixtureModel_newlyfitted.rds")
} else {
    osCN_Fix_mixtureModel <- readRDS("data/osCN_Fix_mixtureModel_newlyfitted.rds")
}
```

```{r mean_and_weights_mixturemodelling_tcga_6335}
# Compare mixture model means and weights from all versions of osCN mixtures
## extract mean and prior for both models from refitting runs
osCN_noFix_mixtureModel_weights <- formatPoisModel(osCN_noFix_mixtureModel$model)
osCN_Fix_mixtureModel_weights <- formatPoisModel(osCN_Fix_mixtureModel$model)

## save mixtures if newly computed
if(!file.exists("data/osCN_oldrefittedVsnew_mixtures.rds")){
    saveRDS(list(osCN_noFix_mixtureModel,osCN_noFix_mixtureModel_weights,
             osCN_Fix_mixtureModel,osCN_Fix_mixtureModel_weights,
             osCN_original_pub_mixtureModel),file = "data/osCN_oldrefittedVsnew_mixtures.rds")
}

compare_weights <- cbind(osCN_original_pub_mixtureModel,osCN_noFix_mixtureModel_weights,osCN_Fix_mixtureModel_weights)
colnames(compare_weights) <- paste0(c("orig","orig","refit","refit","fixed","fixed"),".",colnames(compare_weights))
compare_weights
```

### Generate new mixture model object with new osCN weights

```{r add_new_osCN weights_to_mixtures}
# From newly computed osCN mixtures generate a new data object for use in the package
if(!file.exists("data/Drews2022_v2_TCGA_Mixture_Models.rds")){
    Drews2022_v2_TCGA_Mixture_Models <- Drews2022_TCGA_Mixture_Models
    Drews2022_v2_TCGA_Mixture_Models$osCN <- osCN_Fix_mixtureModel_weights
    saveRDS(Drews2022_v2_TCGA_Mixture_Models,file = "data/Drews2022_v2_TCGA_Mixture_Models.rds")
} else {
    Drews2022_v2_TCGA_Mixture_Models <- readRDS("data/Drews2022_v2_TCGA_Mixture_Models.rds")
}
Drews2022_v2_TCGA_Mixture_Models$osCN
```

## Perform SoP and SxC calculation

Using the newly computed osCN mixtures, recompute and compare the SoP and SxC outcomes from the full TCGA dataset

```{r run_existing_mixtures_tcga_6335}
# Load segment data in CNQuant object and compute old features
tcga_6335_cnquant_oldweights <- createCNQuant(segs_table,experimentName = "tcga_6335_oldMixture")
tcga_6335_cnquant_oldweights <- calculateFeatures(tcga_6335_cnquant_oldweights,method = "drews",cores = 6)

# Check features match in length and value between publication and refit
lapply(names(existingFeats),FUN = function(x){
    t1 <- all(nrow(tcga_6335_cnquant_oldweights@featData[x]) == nrow(existingFeats[x]))
    t2 <- all(tcga_6335_cnquant_oldweights@featData[x]$value == existingFeats[x]$value)
    c(t1,t2)
})

# Manually compute and add the SxC matrix from the old features and mixture models (avoiding wrapper functions in CINSignatureQuantification package)
## Verify the old mixture models were used
tcga_6335_cnquant_oldweights@featFitting <- calculateSampleByComponentMatrixDrews(brECNF = tcga_6335_cnquant_oldweights@featData)
tcga_6335_cnquant_oldweights@featFitting$model$osCN

# Report dimensions and valdiate SxC from CNQuant object
osCN_old_sxc <- getSampleByComponent(tcga_6335_cnquant_oldweights)
head(osCN_old_sxc)
dim(osCN_old_sxc)
```

```{r run_new_mixtures_tcga_6335}
# Generate a new CNQuant object to contain the new SxC data and manually add the old features to save compute time
tcga_6335_cnquant_newweights <- createCNQuant(segs_table,experimentName = "tcga_6335_newMixture")
tcga_6335_cnquant_newweights@featData <- tcga_6335_cnquant_oldweights@featData

## manually replace old osCN with newly computed osCN from earlier
osCN_fix$value <- as.numeric(osCN_fix$value)
tcga_6335_cnquant_newweights@featData$osCN <- osCN_fix

## Compute the SxC matrix using the new implementation with fixed osCN and new mixture model and confirm new mixture used
tcga_6335_cnquant_newweights@featFitting <- calculateSampleByComponentMatrixDrewsV2(brECNF = tcga_6335_cnquant_newweights@featData,
                                                                                    weights=Drews2022_v2_TCGA_Mixture_Models)
tcga_6335_cnquant_newweights@featFitting$model$osCN
```

Extract the newly computed SxC and CxS matrix computed using the fixed osCN feature and newly computed mixture models

```{r get_new_sxc_tcga_6335}
# verify new feature and new model weights
dim(tcga_6335_cnquant_newweights@featData$osCN)
tcga_6335_cnquant_newweights@featFitting$model$osCN

## Extract matrix using CINSignatureQuantification method and transpose to get CxS matrix
osCN_new_sxc <- getSampleByComponent(tcga_6335_cnquant_newweights)
osCN_new_cxs <- t(osCN_new_sxc)

## Check old and new SxC have matching dims across all components except osCN
all(dim(osCN_old_sxc) == dim(osCN_new_sxc))
colCompare <- sapply(1:ncol(osCN_old_sxc),FUN = function(x){ all(osCN_old_sxc[,x] == osCN_new_sxc[,x])})
names(colCompare) <- colnames(osCN_old_sxc)
colCompare

## If CNQuant object, SxC, and CxS not saved then save data to rds
## Additionally write the CxS to tsv for use in ARD-NMF
if(!file.exists("data/tcga_6335_cnquant_newweights.rds")){
    saveRDS(tcga_6335_cnquant_newweights,"data/tcga_6335_cnquant_newweights.rds")
}
if(!file.exists("data/tcga_6335_feats_newweights.rds")){
    saveRDS(tcga_6335_feats_newweights ,"data/tcga_6335_feats_newweights.rds")
}
if(!file.exists("data/tcga_6335_mixture_newweights.rds")){
    saveRDS(tcga_6335_mixture_newweights,"data/tcga_6335_mixture_newweights.rds")
}
if(!file.exists("data/pan_new_oscn_mixture_tcga_SxC.rds")){
    saveRDS(osCN_new_sxc,"data/pan_new_oscn_mixture_tcga_SxC.rds")
}
if(!file.exists("data/pan_new_oscn_mixture_tcga_CxS.rds")){
    saveRDS(osCN_new_cxs,"data/pan_new_oscn_mixture_tcga_CxS.rds")
} 
if(!file.exists("data/pan_new_oscn_mixture_tcga_CxS.tsv")){
    write.table(osCN_new_cxs,file = "data/pan_new_oscn_mixture_tcga_CxS.tsv",quote = F,sep = "\t",row.names = T,col.names = T)
}

```

For validation, test outcome when using new mixture models on original osCN feats

```{r old_feats_new_weights_test}
## Compute SxC matrix using new V2 method which uses new mixtures and original version of input features 
testsxc <- calculateSampleByComponentMatrixDrewsV2(brECNF = tcga_6335_cnquant_oldweights@featData,
                                                                                weights=Drews2022_v2_TCGA_Mixture_Models)
## Extract the SxC
testsxcm <- testsxc$sampleByComponent

## Get osCN components for both original and old features with new mixtures
## Calculate the difference in osCN component weights between two groups
osCN_old_sxc_sub <- osCN_old_sxc[,!colCompare]
testsxcm_sub <- testsxcm[,!colCompare]
test_sxc_diff <- testsxcm_sub - osCN_old_sxc_sub

## Plot mean percentage change differences
barplot(colMeans(test_sxc_diff) / colMeans(osCN_old_sxc_sub))

prop_change_test <- data.frame(test_sxc_diff / osCN_old_sxc_sub  * 100) %>%
    tibble::rownames_to_column("sample") %>%
    tidyr::pivot_longer(cols = 2:ncol(.),names_to = "component",values_to = "percentage_difference")

## Plot percentage change differences by sample
ggplot() +
    geom_point(data=prop_change_test[sample(1:nrow(prop_change_test),size = 2000,replace = F),],
               aes(component,percentage_difference),position = position_jitter(),alpha = 0.05) +
    geom_boxplot(data = prop_change_test,aes(component,percentage_difference)) +
    ylab("percentage change (sum-of-posterior)") +
    #scale_y_continuous(limits = c(0,NA)) +
    facet_wrap(. ~ component,scales = "free_x") + 
    theme_bw()
```

Compare newly computed osCN SxC components using new mixture models and fixed osCN feats. New implementation results in a large increase in osCN3 where the improved osCN capture results in a large number of longer chains terminating at a chromosome end. Example sample `TCGA-5K-AAAP` is used to show this effect.

```{r compare_sxc_tcga_6335_vals}
osCN_new_sxc_sub <- osCN_new_sxc[,!colCompare]

#(colMeans(osCN_new_sxc_sub) - colMeans(osCN_old_sxc_sub)) / colMeans(osCN_old_sxc_sub) * 100
#(colSums(osCN_new_sxc_sub) - colSums(osCN_old_sxc_sub)) / colSums(osCN_old_sxc_sub) * 100

# calculate matrix difference
osCN_new_sxc_diff <- osCN_new_sxc_sub - osCN_old_sxc_sub
# Absolute difference between old and new
sum(abs(osCN_new_sxc_sub)) / sum(osCN_old_sxc_sub)

## Plot mean percentage change differences
barplot(colMeans(osCN_new_sxc_diff) / colMeans(osCN_old_sxc_sub) * 100)

prop_change <- data.frame(osCN_new_sxc_diff / osCN_old_sxc_sub * 100) %>%
    tibble::rownames_to_column("sample") %>%
    tidyr::pivot_longer(cols = 2:ncol(.),names_to = "component",values_to = "percentage_difference")

## Plot percentage change differences by sample
ggplot() +
    geom_point(data=prop_change[sample(1:nrow(prop_change),size = 2000,replace = F),],
               aes(component,percentage_difference),position = position_jitter(),alpha = 0.05) +
    geom_boxplot(data = prop_change,aes(component,percentage_difference)) +
    ylab("percentage change (sum-of-posterior)") +
    #scale_y_continuous(limits = c(0,NA)) +
    facet_wrap(. ~ component,scales = "free") + 
    theme_bw()

prop_change_summary <- prop_change %>%
                        group_by(component) %>%
                        select(-sample) %>%
                        summarise_all(list(mean_percentage_change=mean,
                                           median_percentage_change=median,
                                           sd_percentage_change=sd))

## Print summary statistics for change in osCN components
print(as.data.frame(prop_change_summary))

## Get example of osCN3 component change which results in extreme change to mean and sd change
oldChainCount <- tcga_6335_cnquant_oldweights@featData$osCN[tcga_6335_cnquant_oldweights@featData$osCN$ID == "TCGA-5K-AAAP",]$value
newChainCount <- tcga_6335_cnquant_newweights@featData$osCN[tcga_6335_cnquant_newweights@featData$osCN$ID == "TCGA-5K-AAAP",]$value
data.frame(old_osCN = paste0(oldChainCount,collapse = ","),new_osCN = paste0(newChainCount,collapse = ","),row.names = "TCGA-5K-AAAP")

## Compare all computed weights across each feat-mixture combination for this example sample
## Weight for both osCN2 and osCN3 increase substantially by several orders of magnitude
print(cbind("oldFeat-oldWeight"=osCN_old_sxc[rownames(osCN_old_sxc) == "TCGA-5K-AAAP",41:43],
      "oldFeat-newWeight"=testsxcm[rownames(testsxcm) == "TCGA-5K-AAAP",41:43],
    "newFeat-newWeight"=osCN_new_sxc[rownames(osCN_new_sxc) == "TCGA-5K-AAAP",41:43]))
```
## Generate cancer-specific CxS data

Here CxS matrices are generated identically to the drews publication using cancer subsets with a minimum of 100 samples
These groups are then written to TSV file for use in non-incorporated stand alone ARD-NMF.

```{r generate_cs_sxc_subsets}
## Load sample metadata and get CIN "active" sample set
meta.data <- read.table("data/Metadata_TCGA_ASCAT_penalty70.txt",header = T,sep = "\t")
meta.data.filt <- meta.data[meta.data$dCIN,]

## Split SxC into a list of cancer type specific sub matrices
splitSxC <- splitSxCByGroup(osCN_new_sxc,sampleCol = "name",group = "cancer_type",groupdata = meta.data.filt)

## If not present, write list of groups and grouped matrices to disk for use in ARD-NMF run
if(!file.exists("data/nmf_cxs_groups.txt")){
    writeLines(names(splitSxC),con = "data/nmf_cxs_groups.txt")
}

if(!any(file.exists(paste0("data/",names(splitSxC),"_new_oscn_mixture_tcga_SxC.rds")))){
    lapply(names(splitSxC),FUN = function(x){
        groupName <- x
        grp <- splitSxC[[x]]
        grp_t <- t(grp)
        saveRDS(grp,paste0("data/",groupName,"_new_oscn_mixture_tcga_SxC.rds"))
        saveRDS(grp_t,paste0("data/",groupName,"_new_oscn_mixture_tcga_CxS.rds"))
        write.table(grp_t,file = paste0("data/",groupName,"_new_oscn_mixture_tcga_CxS.tsv"),quote = F,sep = "\t",row.names = T,col.names = T)
    })
}
## Print selected cancer-specific group names
names(splitSxC)
```

## Running ARD-NMF

ARD-NMF, as implemented in the SignatureAnalyzer-GPU python library was performed as described in the Drews publication using the same parameters. Only deviation was the strict use of 200 runs per CxS matrix, rather than 194 and several values close to that number for unknown reasons. The code was implemented on the CRUK CI slurm cluster on CUDA-enabled GPUs. R-based implementation has been constructed that could be feasibly used in this document but has not yet been properly incorporated into the package codebase. Results from the ARD-NMF runs are output to the `nmfruns/results/` sub directory and contains all output matrices and logs for each 200 runs per cancer type and pan-cancer CxS matrix.

The following code would emulate this process in R but has a long execution time so is not evaluated

```{r run_nmf_pan_cs_groups_pseudo,eval=FALSE}
## Pan-cancer
# Run GPU-accelerated ARD-NMF via reticulate and a pre-defined conda env
osCN_new_cxs_nmf <- CINSignatureQuantification::calculateArdNMF(data = osCN_new_cxs,runs = 200,max_iter = 1000)
# From available solutions select the modal k value returned as number of correct signatures using beta_div metric
osCN_new_cxs_nmf_best <- CINSignatureQuantification::choose_ard_nmf(osCN_new_cxs_nmf,method = "modal",decision = "bdiv")

## Cancer-specific (n > 100)
# Same as pan-cancer but input is a cancer-specific CxS matrix
cs_nmf_list <- list()
for(i in names(splitSxC)){
    y <- t(splitSxC[[i]])
    yout <- CINSignatureQuantification::calculateArdNMF(data = y,runs = 200,max_iter = 1000)
    ybest <- CINSignatureQuantification::choose_ard_nmf(yout,method = "modal",decision = "bdiv")
    cs_nmf_list <- append(cs_nmf_list,list(ybest))
}
names(cs_nmf_list) <- names(splitSxC)
```

## Assess ARD-NMF runs

Get cancer-specific list and previously selected K

```{r cs_nmf_tcga_6335_get_nsigs}
## Small code snippet to capture the previously assigned optimal number of signatures from the publication and save the values to file
if(!file.exists("data/cancer_specific_sigs.rds")){
    cancer_specific_sigs <- do.call(rbind,lapply(list.files("../../CINSignatureDiscovery/Denovo_Signature_Discovery/",pattern = "4_",full.names = T),
                                                FUN = function(x){data.frame(cancer=gsub(basename(x),pattern=".txt|4_Signatures_",replacement = ""),
                                                                             sigs=ncol(data.frame(fread(x),row.names = 1)))}))
    saveRDS(cancer_specific_sigs,file = "data/cancer_specific_sigs.rds")
} else {
    cancer_specific_sigs <- readRDS("data/cancer_specific_sigs.rds")
}
```

### Using modal K-values

Optimal ARD-NMF run selection process is applied to the cancer-specific NMF runs and uses modal K value from which to choose the best ARD-NMF run.

```{r load_pan_cancer_nmf_tcga_6335_modal}
## Define the input and output directories for ARD-NMF
PATHTOFILES="nmfruns/results/BayesNMF_pan/"
OUTPUTDIR_modal="nmfruns/solutions_modal/pan_cancer"

## Generate output directory if missing
if(!dir.exists(OUTPUTDIR_modal)){
    dir.create(path = OUTPUTDIR_modal,recursive = T)
}

## Load list of NMF runs from results folder and plot histogram of optimal K values
lResults_modal = loadNMFresults(PATHTOFILES)
plotHist_modal <- plotHistOfKs(lResults_modal$lData)
plotHist_modal
```

```{r select_pan_cancer_nmf_tcga_6335_modal,warning=FALSE,message=FALSE}
## Modal K value is used regardless of match to publication
OVERRIDEK_modal=FALSE
thisK_modal = detK(lResults_modal$lData, OVERRIDEK=OVERRIDEK_modal)

## Identify and extract optimal solution
### fread outputs a bunch of column name warnings but does not seem to be an issue
lOptimal_modal = idOptimalSolution(lResults_modal$lData, lResults_modal$allSamples, PATHTOFILES,
                                   LOGPATTERN="log.txt", thisK = thisK_modal, DECISION="div", OUTPUTDIR=OUTPUTDIR_modal)
bestSolution = lResults_modal$lData[[ lOptimal_modal$bestSample ]]
bestPanSample_modal <- lOptimal_modal$bestSample

## How close are the signatures of the same K?
plotHeat1_modal = plotCosineHeat(lResults_modal$lData, lResults_modal$allSamples, thisK_modal)
plotHeat1_modal
## Plot hairball and heatmap with best solution
plotSigs_modal = plotHairballAndHeatmap(lResults_modal$lData, lResults_modal$allSamples, lOptimal_modal$bestSample, lOptimal_modal$thisK)
catchPlot_modal = ViewHairball(plotSigs_modal$hairball)

#iewHairball(plotSigs$hairball)
#### Combine plots into a pdf and move files from selection solution ("bestSolution") into a user-specified directory
catchTrue = makeOutputFiles(OUTPUTDIR=OUTPUTDIR_modal, lOptimal_modal$bestSample, lOptimal_modal$thisK, plotHist=plotHist_modal, plotHeat1=plotHeat1_modal, plotSigs=plotSigs_modal, PATHTOFILES=PATHTOFILES)
```


```{r run_cs_nmf_tcga_6335_solutions_modal,warning=FALSE,message=FALSE,fig.show='hide'}
# Perform same optimal solution selection for each cancer-specific group as a loop using modal k
for(i in cancer_specific_sigs$cancer){
    cs <- i
    
    PATHTOFILES=paste0("nmfruns/results/BayesNMF_",cs,"/")
    OUTPUTDIR_modal=paste0("nmfruns/solutions_modal/",cs,"_cancer")
    
    if(!dir.exists(OUTPUTDIR_modal)){
        dir.create(path = OUTPUTDIR_modal,recursive = T)
    }
    
    lResults_modal = loadNMFresults(PATHTOFILES)
    #plotHistOfKs(lResults$lData)
    
    OVERRIDEK_modal=FALSE
    print(c(cs,OVERRIDEK_modal))
    thisK_modal = detK(lResults_modal$lData, OVERRIDEK=OVERRIDEK_modal)
    ## Identify and extract optimal solution
    lOptimal_modal = idOptimalSolution(lResults_modal$lData, lResults_modal$allSamples, PATHTOFILES,
                                       LOGPATTERN="log.txt", thisK = thisK_modal, DECISION="div", OUTPUTDIR=OUTPUTDIR_modal)
    
    bestSolution = lResults_modal$lData[[ lOptimal_modal$bestSample ]]
    
    plotHist_modal = plotHistOfKs(lResults_modal$lData)
    ## How close are the signatures of the same K?
    plotHeat1_modal = plotCosineHeat(lResults_modal$lData, lResults_modal$allSamples, thisK_modal)
    ## Plot hairball and heatmap with best solution
    plotSigs_modal = plotHairballAndHeatmap(lResults_modal$lData, lResults_modal$allSamples, lOptimal_modal$bestSample, lOptimal_modal$thisK)
    catchPlot_modal = ViewHairball(plotSigs_modal$hairball)
    
    #ViewHairball(plotSigs$hairball)
    #### Combine plots into a pdf and move files from selection solution ("bestSolution") into a user-specified directory
    catchTrue = makeOutputFiles(OUTPUTDIR=OUTPUTDIR_modal, lOptimal_modal$bestSample, lOptimal_modal$thisK, plotHist=plotHist_modal, plotHeat1=plotHeat1_modal, plotSigs=plotSigs_modal, PATHTOFILES=PATHTOFILES)
}
```

### Using Drews K-values

Get optimal ARD-NMF run for pan-cancer signature sets. Here the selection of optimal ARD-NMF run and preferred k number of signatures are performed as per the publication.

```{r load_pan_cancer_nmf_tcga_6335}
## Define the input and output directories for ARD-NMF
PATHTOFILES="nmfruns/results/BayesNMF_pan/"
OUTPUTDIR="nmfruns/solutions/pan_cancer"

## Generate output directory if missing
if(!dir.exists(OUTPUTDIR)){
    dir.create(path = OUTPUTDIR,recursive = T)
}

## Load list of NMF runs from results folder and plot histogram of optimal K values
lResults = loadNMFresults(PATHTOFILES)
plotHist <- plotHistOfKs(lResults$lData)
plotHist
```

```{r select_pan_cancer_nmf_tcga_6335,warning=FALSE,message=FALSE}
## As a pragmatic decision the Modal K value for pan-cancer is 9 but 10 is used to match with the publication
OVERRIDEK=10
thisK = detK(lResults$lData, OVERRIDEK=OVERRIDEK)

## Identify and extract optimal solution
### fread outputs a bunch of column name warnings but does not seem to be an issue
lOptimal = idOptimalSolution(lResults$lData, lResults$allSamples, PATHTOFILES, LOGPATTERN="log.txt", thisK = thisK, DECISION="div", OUTPUTDIR=OUTPUTDIR)
bestSolution = lResults$lData[[ lOptimal$bestSample ]]
bestPanSample <- lOptimal$bestSample

## How close are the signatures of the same K?
plotHeat1 = plotCosineHeat(lResults$lData, lResults$allSamples, thisK)
plotHeat1
## Plot hairball and heatmap with best solution
plotSigs = plotHairballAndHeatmap(lResults$lData, lResults$allSamples, lOptimal$bestSample, lOptimal$thisK)
catchPlot = ViewHairball(plotSigs$hairball)

#iewHairball(plotSigs$hairball)
#### Combine plots into a pdf and move files from selection solution ("bestSolution") into a user-specified directory
catchTrue = makeOutputFiles(OUTPUTDIR=OUTPUTDIR, lOptimal$bestSample, lOptimal$thisK, plotHist=plotHist, plotHeat1=plotHeat1, plotSigs=plotSigs, PATHTOFILES=PATHTOFILES)
```

The same optimal ARD-NMF run selection process is applied to the cancer-specific NMF runs and uses the previously selected optimal K value from which to choose the best ARD-NMF run.

```{r run_cs_nmf_tcga_6335_solutions,warning=FALSE,message=FALSE,fig.show='hide'}
# Perform same optimal solution selection for each cancer-specific group as a loop
for(i in cancer_specific_sigs$cancer){
    cs <- i
    
    PATHTOFILES=paste0("nmfruns/results/BayesNMF_",cs,"/")
    OUTPUTDIR=paste0("nmfruns/solutions/",cs,"_cancer")
    
    if(!dir.exists(OUTPUTDIR)){
        dir.create(path = OUTPUTDIR,recursive = T)
    }
    
    lResults = loadNMFresults(PATHTOFILES)
    #plotHistOfKs(lResults$lData)
    
    OVERRIDEK=cancer_specific_sigs$sigs[cancer_specific_sigs$cancer == cs]
    print(c(cs,OVERRIDEK))
    thisK = detK(lResults$lData, OVERRIDEK=OVERRIDEK)
    ## Identify and extract optimal solution
    lOptimal = idOptimalSolution(lResults$lData, lResults$allSamples, PATHTOFILES, LOGPATTERN="log.txt", thisK = thisK, DECISION="div", OUTPUTDIR=OUTPUTDIR)
    
    bestSolution = lResults$lData[[ lOptimal$bestSample ]]
    
    plotHist = plotHistOfKs(lResults$lData)
    ## How close are the signatures of the same K?
    plotHeat1 = plotCosineHeat(lResults$lData, lResults$allSamples, thisK)
    ## Plot hairball and heatmap with best solution
    plotSigs = plotHairballAndHeatmap(lResults$lData, lResults$allSamples, lOptimal$bestSample, lOptimal$thisK)
    catchPlot = ViewHairball(plotSigs$hairball)
    
    #ViewHairball(plotSigs$hairball)
    #### Combine plots into a pdf and move files from selection solution ("bestSolution") into a user-specified directory
    catchTrue = makeOutputFiles(OUTPUTDIR=OUTPUTDIR, lOptimal$bestSample, lOptimal$thisK, plotHist=plotHist, plotHeat1=plotHeat1, plotSigs=plotSigs, PATHTOFILES=PATHTOFILES)
}
```

## Combine pan-cancer and cancer-specific

```{r combine_pc_cs_funcs}
## The cosine similarity threshold was previously estimated from simulation data but was not re-run in this analysis 
## As such the same threshold is used to dictate if two signature definitions are linearly dependent or not
COSINETHRESH=0.74

CANCERCOLS="data/TCGA_colour_scheme.txt"
OUTDIR="data/combined_sigs" # specified but not used

# Minor loading of publication TCGA defined colour scheme
cancerCols = read.table(CANCERCOLS, header = FALSE, comment.char = "|")
vCols = as.character(cancerCols$V2)
names(vCols) = cancerCols$V1
vCols = c(vCols, "pan" = "#636363")
```

### Modal k

Here the full compendium is combined and reduced to a representative set of signatures by prioritising pan-cancer signatures (as they are defined on a larger subset) and identifying non-linearly dependent signatures across all cancer-specific signatures using modal k values for each signature set.

```{r combine_pc_cs_tcga_6335_vars_modal}
## Load all the optimal solutions selected from ARD-NMF runs in previous steps for both pan-cancer and cancer-specific sets
PANCANCERSIGS_modal=paste0("nmfruns/solutions_modal/pan_cancer/2_Signatures_",bestPanSample_modal,"_normalised.rds")
PANCANCEREXP_modal=paste0("nmfruns/solutions_modal/pan_cancer/2_Exposures_",bestPanSample_modal,"_normalised.rds")
PATHCANCERSPECIFIC_modal="nmfruns/solutions_modal"
PATTERNSIGS_modal="2_Signatures"
PATTERNEXP_modal="2_Exposures"
```

```{r combine_pc_cs_tcga_6335_load_pc_modal}
# read and verify pan-cancer sig defs and exposures/activities
pcSigs_modal = readSigs(PANCANCERSIGS_modal, name = "pan_cancer")
pcExp_modal = t(readExp(PANCANCEREXP_modal, name = "pan_cancer"))
print(list(defs=head(pcSigs_modal,n = 10)[,1:9],acts=head(pcExp_modal,n = 10)))
```

```{r combine_pc_cs_tcga_6335_load_cs_modal}
# Load all the selected Cancer-specific signatures dropping unneeded files
allCSigFiles_modal = list.files( path = PATHCANCERSPECIFIC_modal, pattern = PATTERNSIGS_modal, full.names = TRUE,recursive = TRUE)
allCSigFiles_modal = allCSigFiles_modal[ grep( "normalised", allCSigFiles_modal, invert = TRUE ) ]
allCSigFiles_modal = allCSigFiles_modal[ grep( "pan_cancer", allCSigFiles_modal, invert = TRUE ) ]
allCSigFiles_modal = allCSigFiles_modal[ grep( "not_used", allCSigFiles_modal, invert = TRUE ) ]
allCSigFiles_modal = allCSigFiles_modal[ grep( "summary", allCSigFiles_modal, invert = TRUE ) ]
lCSigs_modal = lapply(allCSigFiles_modal, function(thisFile) {
    
    thisName = basename(dirname(thisFile))
    thisSig = readSigs(thisFile, name = thisName)
    return(thisSig)
    
} )

## Bind all CS signatures together and check dims
dfCS_modal = do.call(rbind, lCSigs_modal)
matAll_modal = as.matrix( rbind(dfCS_modal, pcSigs_modal) )
head(matAll_modal)
```

```{r combine_pc_cs_tcga_6335_load_ce_modal}
# oad all the selected Cancer-specific exposures
allCExpFiles_modal = list.files( path = PATHCANCERSPECIFIC_modal, pattern = PATTERNEXP_modal, full.names = TRUE,recursive = TRUE)
allCExpFiles_modal = allCExpFiles_modal[ grep( "normalised", allCExpFiles_modal ) ]
allCExpFiles_modal = allCExpFiles_modal[ grep( "not_used", allCExpFiles_modal, invert = TRUE ) ]
lCExp_modal = lapply(allCExpFiles_modal, function(thisFile) {
    
    thisName = basename(dirname(thisFile))
    thisExp = t(readSigs(thisFile, name = thisName))
    return(thisExp)
    
} )
names(lCExp_modal) = basename(dirname(allCExpFiles_modal))
head(lCExp_modal$BLCA_cancer)
```

```{r combine_pc_cs_tcga_6335_hairball_modal}
## Combine all the signature defintions from both pan-cancer and CS and plot hairball
outfileHairball = file.path(OUTDIR, paste0("0_Hairball_PC_and_CS_sigs_cosineSim"))
plotHairball(matAll_modal, outfileHairball, numPCSigs = nrow(pcSigs_modal), corThreshold = COSINETHRESH, 
             cancerCols = cancerCols, corMethod = "cosine", plot2File = FALSE)
```

```{r combine_pc_cs_tcga_6335_corHM_modal}
## plot cosine similarity heatmap of all sigs
corMat_modal = cosine(t(matAll_modal))
Heatmap(corMat_modal, show_row_names = FALSE, show_column_names = FALSE, name = "Cosine_Sim")
```

```{r combine_pc_cs_tcga_6335_corFiltHM_modal}
## plot cosine similarity heatmap of all sigs with a restriction on minimum similiarity
corMatFilt_modal = corMat_modal
corMatFilt_modal[ corMatFilt_modal < COSINETHRESH ] = 0
Heatmap(corMatFilt_modal, show_row_names = FALSE, show_column_names = FALSE, name = "Cosine_Sim")
```

```{r combine_pc_cs_tcga_6335_sigExpCount_modal}
## As a selection metric in CS signatures, the number of samples with activity/exposure above a threshold is computed
dtExposedSamples_modal = samplesPerSignature(lCExp_modal,pcExp_modal, EXPTRESH = 0.05)

dtExposedSamples2_modal <- rownames_to_column(dtExposedSamples_modal,var = "signatureID")

## Plot of the number of samples with activity in a given signature set
ggplot(dtExposedSamples2_modal) +
    geom_col(aes(x = signatureID,y = Samples, fill = Cancer)) +
    #scale_x_log10() + 
    scale_fill_manual(values = vCols) +
    theme_bw() +
    theme(axis.text.x = element_blank(),
          axis.ticks.x = element_blank(),
          legend.position = "none") +
    ylab("Count") + 
    ggtitle("Frequency of signature exposure") +
    guides(fill = guide_legend(ncol= 2)) +
    facet_wrap(vars(Cancer),scales = "free")
```

### Pre-specified k

The full compendium of Pan-cancer and cancer-specific signatures contain many non-linearly independent signature definitions, overlapping component weights, and low activity signatures. Here the full compendium is combined and reduced to a representative set of signatures by prioritising pan-cancer signatures (as they are defined on a larger subset) and identifying non-linearly dependent signatures across all cancer-specific signatures using pre-specified k values for each signature set.

```{r combine_pc_cs_tcga_6335_vars}
## Load all the optimal solutions selected from ARD-NMF runs in previous steps for both pan-cancer and cancer-specific sets
PANCANCERSIGS=paste0("nmfruns/solutions/pan_cancer/2_Signatures_",bestPanSample,"_normalised.rds")
PANCANCEREXP=paste0("nmfruns/solutions/pan_cancer/2_Exposures_",bestPanSample,"_normalised.rds")
PATHCANCERSPECIFIC="nmfruns/solutions"
PATTERNSIGS="2_Signatures"
PATTERNEXP="2_Exposures"
```

```{r combine_pc_cs_tcga_6335_load_pc}
# read and verify pan-cancer sig defs and exposures/activities
pcSigs = readSigs(PANCANCERSIGS, name = "pan_cancer")
pcExp = t(readExp(PANCANCEREXP, name = "pan_cancer"))
print(list(defs=head(pcSigs,n = 10)[,1:9],acts=head(pcExp,n = 10)))
```

```{r combine_pc_cs_tcga_6335_load_cs}
# Load all the selected Cancer-specific signatures dropping unneeded files
allCSigFiles = list.files( path = PATHCANCERSPECIFIC, pattern = PATTERNSIGS, full.names = TRUE,recursive = TRUE)
allCSigFiles = allCSigFiles[ grep( "normalised", allCSigFiles, invert = TRUE ) ]
allCSigFiles = allCSigFiles[ grep( "pan_cancer", allCSigFiles, invert = TRUE ) ]
allCSigFiles = allCSigFiles[ grep( "not_used", allCSigFiles, invert = TRUE ) ]
allCSigFiles = allCSigFiles[ grep( "summary", allCSigFiles, invert = TRUE ) ]
lCSigs = lapply(allCSigFiles, function(thisFile) {
    
    thisName = basename(dirname(thisFile))
    thisSig = readSigs(thisFile, name = thisName)
    return(thisSig)
    
} )

## Bind all CS signatures together and check dims
dfCS = do.call(rbind, lCSigs)
matAll = as.matrix( rbind(dfCS, pcSigs) )
head(matAll)
```

```{r combine_pc_cs_tcga_6335_load_ce}
# oad all the selected Cancer-specific exposures
allCExpFiles = list.files( path = PATHCANCERSPECIFIC, pattern = PATTERNEXP, full.names = TRUE,recursive = TRUE)
allCExpFiles = allCExpFiles[ grep( "normalised", allCExpFiles ) ]
allCExpFiles = allCExpFiles[ grep( "not_used", allCExpFiles, invert = TRUE ) ]
lCExp = lapply(allCExpFiles, function(thisFile) {
    
    thisName = basename(dirname(thisFile))
    thisExp = t(readSigs(thisFile, name = thisName))
    return(thisExp)
    
} )
names(lCExp) = basename(dirname(allCExpFiles))
head(lCExp$BLCA_cancer)
```

```{r combine_pc_cs_tcga_6335_hairball}
## Combine all the signature defintions from both pan-cancer and CS and plot hairball
outfileHairball = file.path(OUTDIR, paste0("0_Hairball_PC_and_CS_sigs_cosineSim"))
plotHairball(matAll, outfileHairball, numPCSigs = nrow(pcSigs), corThreshold = COSINETHRESH, 
             cancerCols = cancerCols, corMethod = "cosine", plot2File = FALSE)
```

```{r combine_pc_cs_tcga_6335_corHM}
## plot cosine similarity heatmap of all sigs
corMat = cosine(t(matAll))
Heatmap(corMat, show_row_names = FALSE, show_column_names = FALSE, name = "Cosine_Sim")
```

```{r combine_pc_cs_tcga_6335_corFiltHM}
## plot cosine similarity heatmap of all sigs with a restriction on minimum similiarity
corMatFilt = corMat
corMatFilt[ corMatFilt < COSINETHRESH ] = 0
Heatmap(corMatFilt, show_row_names = FALSE, show_column_names = FALSE, name = "Cosine_Sim")
```

```{r combine_pc_cs_tcga_6335_sigExpCount}
## As a selection metric in CS signatures, the number of samples with activity/exposure above a threshold is computed
dtExposedSamples = samplesPerSignature(lCExp, pcExp,EXPTRESH = 0.05)

dtExposedSamples2 <- rownames_to_column(dtExposedSamples,var = "signatureID")

## Plot of the number of samples with activity in a given signature set
ggplot(dtExposedSamples2) +
    geom_col(aes(x = signatureID,y = Samples, fill = Cancer)) +
    #scale_x_log10() + 
    scale_fill_manual(values = vCols) +
    theme_bw() +
    theme(axis.text.x = element_blank(),
          axis.ticks.x = element_blank(),
          legend.position = "none") +
    ylab("Count") + 
    ggtitle("Frequency of signature exposure") +
    guides(fill = guide_legend(ncol= 2)) +
    facet_wrap(vars(Cancer),scales = "free")
```
#### Signature difference pre-specified vs modal k

Comparing full signature sets between using previously specified k values for each signature subset versus taking the modal value for each signature subset there is the inclusion of one additional pan-cancer signature and one cancer-specific signature in the pre-specified K group.

```{r compare_pres_vs_modal_fullsig}
r <- rbind(pre=unlist(lapply(lCSigs,nrow)),modal=unlist(lapply(lCSigs_modal,nrow)))
r <- cbind(c(dim(pcSigs)[1],dim(pcSigs_modal)[1]),r)
colnames(r) <- c("pan",cancer_specific_sigs$cancer)
r
rownames(matAll)[which(!rownames(matAll) %in% rownames(matAll_modal))]
```

### Modal k default signature selection

```{r combine_pc_cs_tcga_6335_filtSigs_default_modal,message=FALSE}
## Filter signature compendium to removal all sigs similar to pc sigs
filtMatAll_modal = removePCSimilarSigs(matAll_modal, COSINETHRESH = COSINETHRESH,PREFIXPCSIGS = "pan_cancer")
dim(filtMatAll_modal)

## Filter CS-sigs to remove all non-pan cancer sigs that are similar
csSigs_modal = removeCSSimilarSigs(filtMatAll_modal, dtExposedSamples_modal, COSINETHRESH = 0.74)
dim(csSigs_modal)

## Bind PC and CS sigs
matPCSC_modal = rbind(pcSigs_modal, csSigs_modal)
dim(matPCSC_modal)

## Heatmap plot of new set of signature definitions using publication methodology and outcome
Heatmap(matPCSC_modal, cluster_columns = FALSE, cluster_rows = FALSE, column_title = "New pan-cancer signature compendium",name = "weight")

## Compute and plot intra-signature cosine similarity which shows all except PCw2 and PCW3 are independent at the given threshold
pcvcsCorr_modal <- cosine(t(matPCSC_modal))
Heatmap(pcvcsCorr_modal,column_title = "PC vs CS linear dependence",name = "cosine sim",
        cluster_columns = F, cluster_rows = FALSE,
        cell_fun = function(j, i, x, y, w, h, col) {
            if(round(pcvcsCorr_modal,digits = 2)[i, j] > 0.74){# add text to each grid
        grid.text(round(pcvcsCorr_modal,digits = 2)[i, j], x, y)
            }
    })

## Plot of the number of samples with activity for given signature conpendium
dtExposedSamples_modal[rownames(dtExposedSamples_modal) %in% rownames(matPCSC_modal),] %>%
    rownames_to_column("signatureID") %>%
    ggplot() +
    geom_col(aes(x = signatureID,y = Samples, fill = Cancer)) +
    #scale_x_log10() + 
    scale_fill_manual(values = vCols) +
    theme_bw() +
    # theme(axis.text.x = element_blank(),
    #       axis.ticks.x = element_blank(),
    #       legend.position = "none") +
    ylab("Count") + 
    ggtitle("Frequency of signature exposure") +
    guides(fill = guide_legend(ncol= 2))
    #facet_wrap(vars(Cancer),scales = "free")
```


```{r combine_pc_cs_tcga_6335_compSigsDefs_modal}
## No threshold
plotCosineHeatmap(CINSignatureQuantification::Drews2022_TCGA_Signatures,matPCSC_modal,
                  threshold = 0,title = "Signature definition comparison (no threshold)")

## Designated threhsold from publication
plotCosineHeatmap(CINSignatureQuantification::Drews2022_TCGA_Signatures,matPCSC_modal,
                  threshold = 0.74,title = "Signature definition comparison (cosine >= 0.74)")
matPCSC_modalmap <- getSignatureMapping(x1 = CINSignatureQuantification::Drews2022_TCGA_Signatures,matPCSC_modal,threshold = 0.74)
matPCSC_modalmap

## Strict 0.90 cosine similiarity
# plotCosineHeatmap(CINSignatureQuantification::Drews2022_TCGA_Signatures,matPCSC19,
#                   threshold = 0.90,title = "Signature definition comparison (cosine >= 0.90)")
# getSignatureMapping(x1 = CINSignatureQuantification::Drews2022_TCGA_Signatures,matPCSC19,threshold = 0.90)

## Strict 0.95 cosine similiarity
# plotCosineHeatmap(CINSignatureQuantification::Drews2022_TCGA_Signatures,matPCSC19,
#                   threshold = 0.95,title = "Signature definition comparison (cosine >= 0.95)")
# getSignatureMapping(x1 = CINSignatureQuantification::Drews2022_TCGA_Signatures,matPCSC19,threshold = 0.95)

```

### default signature selection 

Using the provided functions from the publication, select linearly independent sigs from full compendium at the given threshold. Previous cosine threshold of 0.74 resulted in 19 signatures being retained after PC-CS and CS-CS filtering.

```{r combine_pc_cs_tcga_6335_filtSigs_default19,message=FALSE}
## Filter signature compendium to removal all sigs similar to pc sigs
filtMatAll19 = removePCSimilarSigs(matAll, COSINETHRESH = COSINETHRESH,PREFIXPCSIGS = "pan_cancer")
dim(filtMatAll19)

## Filter CS-sigs to remove all non-pan cancer sigs that are similar
csSigs19 = removeCSSimilarSigs(filtMatAll19, dtExposedSamples, COSINETHRESH = 0.74)
dim(csSigs19)

## Bind PC and CS sigs
matPCSC19 = rbind(pcSigs, csSigs19)
dim(matPCSC19)

## Heatmap plot of new set of signature definitions using publication methodology and outcome
Heatmap(matPCSC19, cluster_columns = FALSE, cluster_rows = FALSE, column_title = "New pan-cancer signature compendium",name = "weight")

## Compute and plot intra-signature cosine similarity which shows all except PCw2 and PCW3 are independent at the given threshold
pcvcsCorr19 <- cosine(t(matPCSC19))
Heatmap(pcvcsCorr19,column_title = "PC vs CS linear dependence",name = "cosine sim",
        cluster_columns = F, cluster_rows = FALSE,
        cell_fun = function(j, i, x, y, w, h, col) {
            if(round(pcvcsCorr19,digits = 2)[i, j] > 0.74){# add text to each grid
        grid.text(round(pcvcsCorr19,digits = 2)[i, j], x, y)
            }
    })

## Plot of the number of samples with activity for given signature conpendium
dtExposedSamples[rownames(dtExposedSamples) %in% rownames(matPCSC19),] %>%
    rownames_to_column("signatureID") %>%
    ggplot() +
    geom_col(aes(x = signatureID,y = Samples, fill = Cancer)) +
    #scale_x_log10() + 
    scale_fill_manual(values = vCols) +
    theme_bw() +
    # theme(axis.text.x = element_blank(),
    #       axis.ticks.x = element_blank(),
    #       legend.position = "none") +
    ylab("Count") + 
    ggtitle("Frequency of signature exposure") +
    guides(fill = guide_legend(ncol= 2))
    #facet_wrap(vars(Cancer),scales = "free")
```

As the number of components and number of components per feature are the same between new and original signatures they can be compared directly.
At various cosine similarity thresholds, 

```{r combine_pc_cs_tcga_6335_compSigsDefs19}
## No threshold
plotCosineHeatmap(CINSignatureQuantification::Drews2022_TCGA_Signatures,matPCSC19,
                  threshold = 0,title = "Signature definition comparison (no threshold)")

## Designated threhsold from publication
plotCosineHeatmap(CINSignatureQuantification::Drews2022_TCGA_Signatures,matPCSC19,
                  threshold = 0.74,title = "Signature definition comparison (cosine >= 0.74)")
matPCSC19map <- getSignatureMapping(x1 = CINSignatureQuantification::Drews2022_TCGA_Signatures,matPCSC19,threshold = 0.74)
matPCSC19map

## Strict 0.90 cosine similiarity
# plotCosineHeatmap(CINSignatureQuantification::Drews2022_TCGA_Signatures,matPCSC19,
#                   threshold = 0.90,title = "Signature definition comparison (cosine >= 0.90)")
# getSignatureMapping(x1 = CINSignatureQuantification::Drews2022_TCGA_Signatures,matPCSC19,threshold = 0.90)

## Strict 0.95 cosine similiarity
# plotCosineHeatmap(CINSignatureQuantification::Drews2022_TCGA_Signatures,matPCSC19,
#                   threshold = 0.95,title = "Signature definition comparison (cosine >= 0.95)")
# getSignatureMapping(x1 = CINSignatureQuantification::Drews2022_TCGA_Signatures,matPCSC19,threshold = 0.95)

```

### Conforming to 17 Sigantures

The new selected signature compendium results in 19 signatures, a greater number than those previously described and several signatures from the original set are not represented with corresponding new signature definitions. The threshold on cosine similarity can be adjusted to return 17 signatures, matching the published number, but they do not map any better than the 19 signatures generated by replicating the exact methods in the publication without amendment and results in an increase of multiple mapping to original signatures. 

```{r combine_pc_cs_tcga_6335_filtSigs_default17}
# Previous cosine threshold of 0.74 resulted in 19 signatures being retained after PC-CS and CS-CS filtering
# Dropping the threshold to 0.72 returned 17 signature definitions.

## Filter signature compendium to removal all sigs similar to pc sigs
filtMatAll17 = removePCSimilarSigs(matAll, COSINETHRESH = 0.72,PREFIXPCSIGS = "pan_cancer")
dim(filtMatAll17)

## Filter CS-sigs to remove all non-pan cancer sigs that are similar
csSigs17 = removeCSSimilarSigs(filtMatAll17, dtExposedSamples, COSINETHRESH = 0.72)
dim(csSigs17)

## Bind PC and CS sigs
matPCSC17 = rbind(pcSigs, csSigs17)
dim(matPCSC17)

## Heatmap plot of new set of signature definitions using publication methodology and outcome
Heatmap(matPCSC17, cluster_columns = FALSE, cluster_rows = FALSE, column_title = "New pan-cancer signature compendium",name = "weight")

## Compute and plot intra-signature cosine similarity which shows all except PCw2 and PCW3 are independent at the given threshold
pcvcsCorr17 <- cosine(t(matPCSC17))
Heatmap(pcvcsCorr17,column_title = "PC vs CS linear dependence",name = "cosine sim",
        cluster_columns = F, cluster_rows = FALSE,
        cell_fun = function(j, i, x, y, w, h, col) {
            if(round(pcvcsCorr17,digits = 2)[i, j] > 0.74){# add text to each grid
        grid.text(round(pcvcsCorr17,digits = 2)[i, j], x, y)
            }
    })

## Plot of the number of samples with activity for given signature conpendium
dtExposedSamples[rownames(dtExposedSamples) %in% rownames(matPCSC17),] %>%
    rownames_to_column("signatureID") %>%
    ggplot() +
    geom_col(aes(x = signatureID,y = Samples, fill = Cancer)) +
    #scale_x_log10() + 
    scale_fill_manual(values = vCols) +
    theme_bw() +
    # theme(axis.text.x = element_blank(),
    #       axis.ticks.x = element_blank(),
    #       legend.position = "none") +
    ylab("Count") + 
    ggtitle("Frequency of signature exposure") +
    guides(fill = guide_legend(ncol= 2))
    #facet_wrap(vars(Cancer),scales = "free")
```


```{r combine_pc_cs_tcga_6335_compSigsDefs17}
## No threshold
plotCosineHeatmap(CINSignatureQuantification::Drews2022_TCGA_Signatures,matPCSC17,
                  threshold = 0,title = "Signature definition comparison (no threshold)")

## Designated threhsold from publication
plotCosineHeatmap(CINSignatureQuantification::Drews2022_TCGA_Signatures,matPCSC17,
                  threshold = 0.72,title = "Signature definition comparison (cosine >= 0.72)")
matPCSC17map <- getSignatureMapping(x1 = CINSignatureQuantification::Drews2022_TCGA_Signatures,matPCSC17,threshold = 0.72)
matPCSC17map
## Strict 0.90 cosine similiarity
# plotCosineHeatmap(CINSignatureQuantification::Drews2022_TCGA_Signatures,matPCSC17,
#                   threshold = 0.90,title = "Signature definition comparison (cosine >= 0.90)")
# getSignatureMapping(x1 = CINSignatureQuantification::Drews2022_TCGA_Signatures,matPCSC17,threshold = 0.90)

## Strict 0.95 cosine similiarity
# plotCosineHeatmap(CINSignatureQuantification::Drews2022_TCGA_Signatures,matPCSC17,
#                   threshold = 0.95,title = "Signature definition comparison (cosine >= 0.95)")
# getSignatureMapping(x1 = CINSignatureQuantification::Drews2022_TCGA_Signatures,matPCSC17,threshold = 0.95)

```

### Prioritsing mapping over independence

An alternative approach is to attempt to select signature definitions which most closely align with the original signature definitions. Signatures selected in this way have no multiple mapping issues where new signatures map to multiple original signatures but the resulting signature set has substantially more linear dependencies between new signatures and original signatures.

```{r combine_pc_cs_tcga_6335_compSigsDefsall,warning=FALSE}
## Plots comparing all new sig defs to existing signatures at various consine similarity thresholds demonstrating 
## the overlapping and multiple mapping of PC and SC sigs to original
plotCosineHeatmap(CINSignatureQuantification::Drews2022_TCGA_Signatures,matAll,
                  threshold = 0.74,title = "Signature definition comparison (cosine >= 0.74)")

# plotCosineHeatmap(CINSignatureQuantification::Drews2022_TCGA_Signatures,matAll,
#                   threshold = 0.90,title = "Signature definition comparison (cosine >= 0.90)")
# 
# plotCosineHeatmap(CINSignatureQuantification::Drews2022_TCGA_Signatures,matAll,
#                   threshold = 0.95,title = "Signature definition comparison (cosine >= 0.95)")
```

```{r manual_curation_sig_defs_tcga_6335}
## Subset cosine similarity matrix to new vs original sigs
compOldNewCosineFiltThreshAll <- cosine(t(rbind(CINSignatureQuantification::Drews2022_TCGA_Signatures,matAll)))
compOldNewCosineFiltThreshAll <- compOldNewCosineFiltThreshAll[,!colnames(compOldNewCosineFiltThreshAll) %in% paste0("CX",seq_len(17))]
compOldNewCosineFiltThreshAll <- compOldNewCosineFiltThreshAll[rownames(compOldNewCosineFiltThreshAll) %in% paste0("CX",seq_len(17)),]
head(compOldNewCosineFiltThreshAll)[,1:12]
```

```{r manual_curation2_sig_defs_tcga_6335}
## For each original signature get vector of new sigs which are greater than the cosine threshold
sigList <- apply(compOldNewCosineFiltThreshAll,MARGIN = 1,FUN = function(x) sort(x[which(x >= COSINETHRESH)],decreasing = T))

# Selection process - highest matching pan_cancer sigs else take highest CS
sigListFilt <- lapply(sigList,FUN = function(x){
    n <- names(x)
    if(any(grepl(x = names(x),pattern = "pan_cancer*",perl = T))){
        y <- x[grep(x = names(x),pattern = "pan_cancer*",perl = T)]
        s <- y[which(max(y) == y)]
    } else {
        s <- x[which(max(x) == x)]
    }
    return(s)
})

# fix names and object type
sigName <- names(sigListFilt)
names(sigListFilt) <- NULL
sigListFiltNames <- names(unlist(sigListFilt))
names(sigListFiltNames) <- sigName
#sigListFiltNames

## Direct intervention for CX15 and corresponding new sigs as pan_cancer_W3 appeared twice
#which(duplicated(sigListFiltNames))
sigListFiltNames[which(duplicated(sigListFiltNames))] <- names(sigList[[which(duplicated(sigListFiltNames))]][1])

## Assign and select sigs from full matrix of new sigs
matFiltThreshAll_sub <- matAll[sigListFiltNames,]

## Subset cosine similarity matrix to selected signatures
compOldNewCosineFiltThreshAll_sub <- compOldNewCosineFiltThreshAll[,sigListFiltNames]
# Validate all original signatures are present
all(paste0("pan_cancer_W",seq_len(10)) %in% colnames(compOldNewCosineFiltThreshAll_sub))
```

```{r manual_curation3_sig_defs_tcga_6335}
# Plot all the same plots as previous iterations
# Cosine sim to original 
plotCosineHeatmap(CINSignatureQuantification::Drews2022_TCGA_Signatures,matFiltThreshAll_sub,
                  threshold = 0.74,title = "Signature definition comparison (cosine >= 0.74)")

# intra signature dependence
matFiltThreshAll_subCosine <- cosine(t(matFiltThreshAll_sub))
Heatmap(matFiltThreshAll_subCosine,column_title = "linear dependence",name = "cosine sim",
        cluster_columns = F, cluster_rows = FALSE,
        cell_fun = function(j, i, x, y, w, h, col) {
            if(round(matFiltThreshAll_subCosine,digits = 2)[i, j] > 0.74){# add text to each grid
        grid.text(round(matFiltThreshAll_subCosine,digits = 2)[i, j], x, y)
            }
    })

# signature exposure frequency in selected signatures
dtExposedSamples[rownames(dtExposedSamples) %in% colnames(compOldNewCosineFiltThreshAll_sub),] %>%
    rownames_to_column("signatureID") %>%
    ggplot() +
    geom_col(aes(x = signatureID,y = Samples, fill = Cancer)) +
    #scale_x_log10() + 
    scale_fill_manual(values = vCols) +
    theme_bw() +
    # theme(axis.text.x = element_blank(),
    #       axis.ticks.x = element_blank(),
    #       legend.position = "none") +
    ylab("Count") + 
    ggtitle("Frequency of signature exposure") +
    guides(fill = guide_legend(ncol= 2))
    #facet_wrap(vars(Cancer),scales = "free")

# Signature mapping to original sigs
matPCSCAllmap <- getSignatureMapping(CINSignatureQuantification::Drews2022_TCGA_Signatures,matFiltThreshAll_sub,
                  threshold = 0.74)
matPCSCAllmap
```

```{r manual_curation_selection_vis_tcga_6335}
## examine the other possible slections for each original signature based on cosine similarity  
selectedList <- data.frame(old=sigName,new=sigListFiltNames,selected=rep("selected",times=length(sigName)))

as.data.frame(compOldNewCosineFiltThreshAll_sub) %>%
    rownames_to_column("old_signature") %>%
    pivot_longer(cols = 2:ncol(.),names_to = "new_signature",values_to = "cosineSim") %>%
    left_join(.,selectedList,by = c("old_signature"="old","new_signature"="new")) %>%
    filter(cosineSim != 0) %>%
    mutate("old_signature" = factor(old_signature,levels=stringr::str_sort(sigName,numeric = T))) %>%
    ggplot() +
    geom_col(aes(new_signature,cosineSim,fill=selected)) +
    facet_wrap(. ~ old_signature,ncol = 3) +
    theme(axis.text.x = element_text(angle = 180)) +
    theme_bw()
```

## Selection of signature definition

In order to remain agnostic to previous solutions, it was elected to use the unaltered version of the selection method with pre-specified k values (the **pre-specified k / original threshold** signature definition set).

* modal k - Use of modally selected k values for optimal number of signatures per group resulted in 19 signatures (9 pan-cancer) which matches with the pre-specified k-value number but with a reduced pan-cancer representation. Additionally, this set had a poorer mapping to the original signatures, with a greater amount of signatures mapping to multiple original signatures compared to other definitions. Overall, the linear dependence was on par with the other groups which did not use manual mapping

* **pre-specified k / original threshold** - Adjusting the optimal number of k signatures for both pan-cancer and BLCA cancer subtypes by an increment of 1 resulted in the same number of pan-cancer signatures as previously described and better mapping to original signature definitions. Linear independence across signature definitions was in line with both the modal k and threshold-adjusted implementation.

* pre-specified k / adjusted threshold - Adjusting the cosine similarity threshold to 0.72 resulted in obtaining the same number of linearly independent signatures as the previous implementation in the Drews paper but resulted in higher number of multiple mappings between original and newly generated signature definitions compared to using the original threshold set.

* pre-specified k / manual mapping - Lastly, adjusting the signature selection method to focus on singularly mapping new signature definitions to the previous definitions resulted in appreciably better correlations between the two sets but introduced a large amount of linear dependence between new signature definitions.

```{r newvsold_conpendium_tcga_6335,message=F}
## plot original and newly chosen signature compendium
oldSigDefs <- CINSignatureQuantification::Drews2022_TCGA_Signatures
suppressMessages(Heatmap(oldSigDefs, cluster_columns = FALSE,cluster_rows = FALSE, column_title = "Drews 2022 signatures",name="weight"))
suppressMessages(Heatmap(matPCSC19, cluster_columns = FALSE,cluster_rows = FALSE, column_title = "New pan-cancer signature compendium",name = "weight"))
```

``````{r newvsold_conpendium_tcga_6335_combplot,message=F}
## By taking the mapping data matrix containing both mapped and unmapped signatures can be generated
## This collectively plots component weights from both original and new signature definitions together
compNames <- colnames(matPCSC19)

group1 <- matrix(rbind(t(matPCSC19[rownames(matPCSC19) %in% matPCSC19map$name[1:8],]),
                       t(oldSigDefs[rownames(oldSigDefs) %in% rownames(matPCSC19map)[1:8],])), ncol=43, byrow=TRUE)
colnames(group1) <- compNames
rownames(group1) <- c(rbind(matPCSC19map$name[1:8],rownames(matPCSC19map[1:8,])))
    
group2 <- oldSigDefs[rownames(oldSigDefs) %in% c("CX9","CX10"),]
rownames(group2) <- c("CX9","CX10")

group3 <- matrix(rbind(t(matPCSC19[rownames(matPCSC19) %in% matPCSC19map$name[11:16],]),
                       t(oldSigDefs[rownames(oldSigDefs) %in% rownames(matPCSC19map)[11:16],])), ncol=43, byrow=TRUE)
colnames(group3) <- compNames
rownames(group3) <- c(rbind(matPCSC19map$name[11:16],rownames(matPCSC19map[11:16,])))

group4 <- t(as.matrix(oldSigDefs[rownames(oldSigDefs) %in% c("CX17"),]))
rownames(group4) <- paste0(rownames(matPCSC19map[17,]))

group5 <- matPCSC19[!rownames(matPCSC19) %in% matPCSC19map$name,]

mapped_group <- rbind(group1,group3)
original_group <- rbind(group2,group4)
new_group <- group5

oldNewSigsCombinedMat <- rbind(mapped_group,original_group,new_group)

row_split <- c(rep("mapped",nrow(mapped_group)),rep("original",nrow(original_group)),rep("new",nrow(group5)))
suppressMessages(Heatmap(oldNewSigsCombinedMat,
                         row_split = row_split,
                         row_title_rot = 0,
                         cluster_columns = FALSE,
                         cluster_rows = T, column_title = "Combined signature compendium - For reference only",name = "weight"))
```

```{r newvsold_conpendium_tcga_6335,message=F}
mapping_alluvial <- matPCSC19map %>%
    rownames_to_column("original") %>%
    mutate(name = ifelse(cosineSim < 0.9,"",name)) %>%
    mutate(cosineSim = ifelse(cosineSim < 0.9,"",cosineSim)) %>%
    mutate(name = ifelse(name == "","old unmapped",name))

missing_new <- sort(rownames(matPCSC19)[!rownames(matPCSC19) %in% mapping_alluvial$name])
missing_new_tab <- cbind(original=rep("new unmapped",times = length(missing_new)),name=missing_new,cosineSim="")
mapping_alluvial <- rbind(mapping_alluvial[,1:3],missing_new_tab)

mapping_alluvial <- mapping_alluvial %>%
        mutate(name = factor(name,levels=c(rownames(matPCSC19),"old unmapped"))) %>%
        mutate(original = factor(original,levels=stringr::str_sort(unique(original),numeric = T)))

ggplot(mapping_alluvial,aes(axis1=original,axis2=name)) +
    geom_alluvium(aes(fill=as.numeric(cosineSim))) +
    scale_fill_gradient2(mid="white", high="red",name = "cosine similarity",limits = c(0,1)) +
    geom_stratum(width = 0.4, fill = "white") +
    geom_text(stat = "stratum",size = 5, aes(label = after_stat(stratum))) +
    theme_void() +
    theme(legend.position = "bottom",
          panel.grid = element_blank()) +
    ggtitle(label = "Canonical alluvial mapping",subtitle = "one-to-one - Pre-specified K - Cosine threshold = 0.74")
```

```{r save_new_conpendium_tcga_6335}
if(!file.exists("data/new_pan_cancer_sig_definition_compendium_tcga_6335.rds")){
    saveRDS(matPCSC19,"data/new_pan_cancer_sig_definition_compendium_tcga_6335.rds")
}

if(!file.exists("data/new_pan_cancer_sig_definition_compendium_map_tcga_6335.rds")){
    saveRDS(matPCSC19map,"data/new_pan_cancer_sig_definition_compendium_map_tcga_6335.rds")
}
```

## Compute new activities

Newly selected signature definitions require generation of signature activities, implementation of new zero-activity thresholds, normalisation, scaling implementation, and comparisons to previously generated signature activities from the original osCN version. Here, a analysis checkpoint is implemented to allow for direct continuation from this point without running the prior analysis.

## ANALYSIS CHECKPOINT

```{r libs2,message=F,warning=F}
library(ggplot2)
library(dplyr)
library(tidyr)
library(tibble)
library(data.table)
library(ComplexHeatmap)
library(ggplot2)
library(igraph)
library(qgraph)
library(lsa)
library(ggthemes)
library(ggalluvial)
library(CINSignatureQuantification) # install getOS-count branch of package
```

```{r funcs2}
source("osCN_source_funcs.R")
```

Using newly implemented V2 function (temp implementation without dedicated data object loading) to compute new signature activities defined on new mixtures, SxC matrix, and ARD-NMF runs.

```{r get_sig_acts_new_definitions_loadData}
osCN_new_feats <- readRDS("data/tcga_6335_feats_newweights.rds")
osCN_new_sxc <- readRDS("data/pan_new_oscn_mixture_tcga_SxC.rds")
osCN_new_models <- readRDS("data/tcga_6335_mixture_newweights.rds")
osCN_new_sigDef <- readRDS("data/new_pan_cancer_sig_definition_compendium_tcga_6335.rds")
tcga_gold_orig_CNquant <- CINSignatureQuantification::quantifyCNSignatures(TCGA_478_Samples_SNP6_GOLD,method = "drews")
```

Signature activities are computed using the new signature definitions described previously, after which the signature activities generated by least squares linear decomposition and normalised to values between 0 and 1 for each sample.

```{r get_sig_acts_new_definitions_generateSigs}
if(!file.exists("data/normaliseNewActs_NewSig_NewMix_noThresh.rds")){
    newActs_NewSig_NewMix_noThresh <- calculateActivityDrewsV2(object = osCN_new_sxc,SIGS = osCN_new_sigDef)
    normaliseNewActs_NewSig_NewMix_noThresh <- t(apply(newActs_NewSig_NewMix_noThresh,2,function(x) x/sum(x)))
    saveRDS(normaliseNewActs_NewSig_NewMix_noThresh,"data/normaliseNewActs_NewSig_NewMix_noThresh.rds")
} else {
    normaliseNewActs_NewSig_NewMix_noThresh <- readRDS("data/normaliseNewActs_NewSig_NewMix_noThresh.rds")
}
head(normaliseNewActs_NewSig_NewMix_noThresh)
```

### Compute signature thresholds

For each given signature, an estimated threshold for determining zero activity for signature exposure. This estimates the signature activity at which a non-zero signature exposure is due to noise rather than signal from a given mutational process. This was performed as described in the Drews publication with functions refactored to allow for future implementation into the signature package. Here, noise is simulated on newly computed features, feature mixture models, and signature definitions to generate 1000 signature activity matrices over which several methods are applied to identify different signature-specific thresholds.

```{r estimate_sig_thresholds_tcga_6335_sig19}
if(!file.exists("data/new_sig19_tcga_thresholds.rds")){
    future::plan("multisession", workers = 10)
    new_sig19_tcga_thresholds <- estimateThresholds(feats = osCN_new_feats,
                                                sigDefs = osCN_new_sigDef,
                                                sigActs = normaliseNewActs_NewSig_NewMix_noThresh,
                                                mixtures = osCN_new_models,
                                                iters = 1000,method = "drewsV2",parallel = TRUE)
    saveRDS(new_sig19_tcga_thresholds,file = "data/new_sig19_tcga_thresholds.rds")
    future::plan("sequential")
} else {
    new_sig19_tcga_thresholds <- readRDS("data/new_sig19_tcga_thresholds.rds")
}
head(new_sig19_tcga_thresholds)
```
The same process was applied to the TCGA gold standard set rather than the full TCGA 6335 sample set to compare threshold differences but were broadly the same. This code is not set to be evaluated as it is not of any further use downstream and thresholds from the full 6335 set are used. 

```{r estimate_sig_thresholds_tcga_gold_sig19,eval=FALSE}
## Use only the TCGA gold standard set to produce thresholds
## no reasonable difference so using full set of 6335 is preferable
TCGA_GOLD_SAMPLES <- unique(TCGA_478_Samples_SNP6_GOLD$sample)
osCN_new_feats_gold <- lapply(osCN_new_feats,FUN = function(x) x[x[,1] %in% TCGA_GOLD_SAMPLES,])
normaliseNewActs_NewSig_NewMix_noThresh_gold <- normaliseNewActs_NewSig_NewMix_noThresh[rownames(normaliseNewActs_NewSig_NewMix_noThresh) %in% TCGA_GOLD_SAMPLES,]

if(!file.exists("data/new_sig19_tcgaGOLD_thresholds.rds")){
    future::plan("multisession", workers = 5)
    new_sig19_tcgaGOLD_thresholds <- estimateThresholds(feats = osCN_new_feats_gold,
                                                sigDefs = osCN_new_sigDef,
                                                sigActs = normaliseNewActs_NewSig_NewMix_noThresh_gold,
                                                mixtures = osCN_new_models,
                                                iters = 1000,method = "drewsV2",parallel = TRUE)
    saveRDS(new_sig19_tcgaGOLD_thresholds,file = "data/new_sig19_tcgaGOLD_thresholds.rds")
    future::plan("sequential")
} else {
    new_sig19_tcgaGOLD_thresholds <- readRDS("data/new_sig19_tcgaGOLD_thresholds.rds")
}
```

Newly computed thresholds are broadly consistent with the original thresholds for those signature definitions that mapped.

```{r compare_sig_act_thresholds_tcga_6335}
# Publication and Drews method uses the 0.05/0.95 percentile as threshold for sigature activity
Drews2022_V2_TCGA_Signature_Thresholds <- new_sig19_tcga_thresholds[,"Thresh_ZeroGMM_0.05"]

original_sig_thresholds <- Drews2022_TCGA_Signature_Thresholds

## dput output from oldNewSigsCombinedMat to preserve checkpoint
signames <- c("pan_cancer_W2", "CX1", "pan_cancer_W7", "CX2", "pan_cancer_W3", 
"CX3", "pan_cancer_W6", "CX4", "pan_cancer_W9", "CX5", "pan_cancer_W5", 
"CX6", "pan_cancer_W4", "CX7", "pan_cancer_W10", "CX8", "LIHC_cancer_W2", 
"CX11", "pan_cancer_W8", "CX12", "pan_cancer_W1", "CX13", "GBM_cancer_W4", 
"CX14", "GBM_cancer_W8", "CX15", "COAD_cancer_W5", "CX16", "CX9", 
"CX10", "CX17", "CESC_cancer_W2", "UCEC_cancer_W3", "UCEC_cancer_W4", 
"PRAD_cancer_W4", "HNSC_cancer_W3")

## dput output from row_split to preserve checkpoint
groupnames <- c("mapped", "mapped", "mapped", "mapped", "mapped", "mapped", 
"mapped", "mapped", "mapped", "mapped", "mapped", "mapped", "mapped", 
"mapped", "mapped", "mapped", "mapped", "mapped", "mapped", "mapped", 
"mapped", "mapped", "mapped", "mapped", "mapped", "mapped", "mapped", 
"mapped", "original", "original", "original", "new", "new", "new", 
"new", "new")

groupCols <- c(c(rbind(rep("new",14),rep("orig",14))),rep("orig",3),rep("new",5))

threshold_map <- data.frame(signature=signames,
           original_threshold=original_sig_thresholds[match(signames,names(original_sig_thresholds))],
           new_threshold=Drews2022_V2_TCGA_Signature_Thresholds[match(signames,names(Drews2022_V2_TCGA_Signature_Thresholds))]) %>%
    unite(value,original_threshold,new_threshold,na.rm = T,remove = T) %>%
    mutate(value = as.numeric(value)) %>%
    mutate(signature = factor(signature,levels = signames)) %>%
    mutate(group = groupnames) %>%
    mutate(groupCols = groupCols)

ggplot(threshold_map) +
    geom_crossbar(aes(x = signature,y = value,ymin = value,ymax = value,colour=groupCols)) +
    facet_grid (.~ group, scales = "free_x", space = "free_x") +
    #scale_y_continuous(labels = scales::percent) +
    ggtitle("Signature activity threshold - Thresh_ZeroGMM_0.05") +
    theme_bw() +
    theme(axis.line = element_blank(), axis.ticks = element_line(linewidth = 1),
        axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
```

### Thresholded signature activites

```{r apply_sig_act_thresholds_tcga_6335}
ThreshNormaliseNewActs_NewSig_NewMix = sapply(names(Drews2022_V2_TCGA_Signature_Thresholds), function(thisSig) {

        sigVals = normaliseNewActs_NewSig_NewMix_noThresh[,thisSig]
        sigVals[ sigVals < Drews2022_V2_TCGA_Signature_Thresholds[thisSig] ] = 0

        return(sigVals)
    })

threshold_signature_order <- data.frame(prop_act=sort(apply(ThreshNormaliseNewActs_NewSig_NewMix,MARGIN = 2,FUN = function(x) sum(x > 0) / length(x)),decreasing = T)) %>%
    rownames_to_column("signature") %>%
    mutate(signature = factor(signature,levels=signature))

ggplot(threshold_signature_order) +
    geom_col(aes(signature,prop_act)) +
    theme_bw() +
    theme(axis.line = element_blank(), axis.ticks = element_line(linewidth = 1),
        axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
```
Thresholded signature activities were computed across the TCGA gold standard set for both the original and new implementation of the signatures and cosine similarity between mapped signature definitions was performed to assess how well signature activities corresponed to one another after signature activity extraction.

```{r tcga_gold_sig_acts}
tcga_gold_orig <- getActivities(tcga_gold_orig_CNquant)
tcga_gold_new <- ThreshNormaliseNewActs_NewSig_NewMix[rownames(ThreshNormaliseNewActs_NewSig_NewMix) %in% getSamples(tcga_gold_orig_CNquant),]

oldNames <- signames[seq(2,28,2)]
newNames <- signames[seq(1,28,2)]

tcga_gold_orig_filt <- tcga_gold_orig[,oldNames]
tcga_gold_new_filt <- tcga_gold_new[,newNames]

plotCosineHeatmap(t(tcga_gold_orig),t(tcga_gold_new[,threshold_signature_order$signature]),
                  threshold = 0.5,title = "Signature activity (TCGA gold) - all")

plotCosineHeatmap(t(tcga_gold_orig_filt),t(tcga_gold_new_filt[,as.character(threshold_signature_order$signature[threshold_signature_order$signature %in% newNames])]),
                  threshold = 0.4,title = "Signature activity (TCGA gold) - mapped")
```
It is also worth comparing the rate of zero-activities between the two implementaions to identify if mapped signatures have differing rates of zeros.

```{r tcga_gold_sig_zeros}
tcga_gold_orig_zeros <- apply(tcga_gold_orig,MARGIN = 2,FUN = function(x) sum(x == 0) / length(x))
tcga_gold_new_zeros <- apply(tcga_gold_new,MARGIN = 2,FUN = function(x) sum(x == 0) / length(x))

zeros_map <- data.frame(signature=signames,
           original_threshold=tcga_gold_orig_zeros[match(signames,names(tcga_gold_orig_zeros))],
           new_threshold=tcga_gold_new_zeros[match(signames,names(tcga_gold_new_zeros))]) %>%
    unite(value,original_threshold,new_threshold,na.rm = T,remove = T) %>%
    mutate(value = as.numeric(value)) %>%
    mutate(signature = factor(signature,levels = signames)) %>%
    mutate(group = groupnames) %>%
    mutate(groupCols = groupCols)

ggplot(zeros_map) +
    geom_col(aes(x = signature,y = value,fill=groupCols)) +
    facet_grid (.~ group, scales = "free_x", space = "free_x") +
    #scale_y_continuous(labels = scales::percent) +
    ggtitle("Signature activity zeros - TCGA gold") +
    theme_bw() +
    theme(axis.line = element_blank(), axis.ticks = element_line(linewidth = 1),
        axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
```

```{r sessionInfo}
sessionInfo()
```
