% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/calculateArdNMF.R
\name{calculateArdNMF}
\alias{calculateArdNMF}
\title{calculateArdNMF}
\usage{
calculateArdNMF(
  data = NULL,
  runs = 1,
  max_iter = 10000,
  regularisation_W = "L1",
  regularisation_H = "L1",
  additional.args = NULL,
  parallel = FALSE
)
}
\arguments{
\item{runs}{Number of runs to perform from which to select best ARD-NMF
solution (Default: 1)}

\item{max_iter}{Maximum number of iterations for each run to converge
(Default: 10000)}

\item{regularisation_W}{Regularisation term for W provided to ARD-NMF
(Default: "L1")}

\item{regularisation_H}{Regularisation term for W provided to ARD-NMF
(Default: "L1")}

\item{additional.args}{A list of additional arguments to pass to ARD-NMF
which are checked against all available arguments}

\item{parallel}{Use doFuture parallelisation to implement runs set by future::plan()}

\item{object}{A object of class CNQuant with Sample-by-component matrix data}
}
\value{
list of ARD-NMF solutions equal to the number of runs
}
\description{
calculateArdNMF
}
\details{
This function computes ARD-NMF on the provided sample-by-component
matrix using a GPU-accelerated implementation originally in the
\link[=https://github.com/broadinstitute/SignatureAnalyzer-GPU]{SignatureAnalyzer-GPU}
repository. The python code is implemented via the
\link[=https://cloud.r-project.org/web/packages/reticulate/index.html]{reticulate}
package which set handles virtual environment set up, argument passing, and
returning ARD-NMF outputs.

parallelisation is implemented via the doFuture package, then plan() for which can be
specified in the global environment prior to running the function.
Additionally, function calls are included to allow for the use of the
progressr package to provide progress bars for both sequential and parallel
processing.
}
